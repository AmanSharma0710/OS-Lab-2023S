#include<iostream>
#include<vector>
#include<fstream>
#include<string>
#include<cmath>
#include<pthread.h>
#include<queue>
#include<stack>
#include<set>
#include<time.h>
#include<unistd.h>

#define NNODES 37700

using namespace std;

class Action{
    public:
        int user_id;
        int action_id;
        string action_type;
        time_t timestamp;
        Action(int user_id, int action_id, string action_type, time_t timestamp){
            this->user_id = user_id;
            this->action_id = action_id;
            this->action_type = action_type;
            this->timestamp = timestamp;
        }
        void Print(){
            // convert timestamp to readable format
            string time = ctime(&timestamp);
            cout<<"User_id: "<<user_id<<" Action_id: "<<action_id<<" Action: "<<action_type<<" Timestamp: "<<time;    
        }
};

class Node{
    public:
        int id;
        vector<int> neighbors;
        int priority;
        //     Each node U should maintain two queues:
        // ● Wall Queue: Will store the actions generated by the node U herself (see
        // below userSimulator thread function).
        // ● Feed Queue: Will store the actions generated by all neighbors of U (see
        // below readPost and pushUpdate functionalities).
        vector<pair<int, Action>> wallQueue;
        // TODO: change this to a priority queue which will be sorted by priority and timestamp
        vector<pair<int, Action>> feedQueue;
        // TODO: should number of actions or actions be stored in the node?
        Node(){
            this->id = -1;
            this->neighbors = vector<int>();
            this->priority = -1;
        }
        Node(int id){
            this->id = id;
            this->neighbors = vector<int>();
            this->priority = -1;
        }
        void addNeighbor(int id){
            neighbors.push_back(id);
        }
        void Print(){
            cout << "Node: " << id << endl;
            cout << "Neighbors: ";
            for(int i=0; i<neighbors.size(); i++){
                cout << neighbors[i] << " ";
            }
            cout << endl;
        }
};

vector<Node> nodes(NNODES);

void ReadGraph(){
    int edges = 0;
    for(int i=0; i<NNODES; i++){
        nodes[i] = Node(i+1);
    }
    // read the nodes from the musae_git_edges.csv file
    // the first row contains the headers, ignore that
    // after that each row will have 2 columns denoting an edge between the nodes
    ifstream file("musae_git_edges.csv");
    string line;
    // ignoring the headers;
    getline(file, line);
    while(getline(file, line)){
        int node1, node2;
        int pos = line.find(",");
        node1 = stoi(line.substr(0, pos));
        node2 = stoi(line.substr(pos+1, line.length()));
        nodes[node1].addNeighbor(node2);
        nodes[node2].addNeighbor(node1);
        edges++;

    }
    // cout<<"Number of edges: " << edges << endl;
    // cout<<"Number of nodes: " << NNODES << endl;
    file.close();
}

void *userSimulatorFn(void *arg){
    // this function will be executed by the userSimulator thread
    // it will generate random actions for 100 random users 
    // and push them to the wall queue of the user node
    // and push them to a queue monitored by pushUpdate threads
    while(true){
        // We will also log these statements in sns.log file
        FILE* fp = fopen("sns.log", "a");
        cout<<"-------------------------------------------------------------------------"<<endl;
        // write this into the log file
        fprintf(fp, "-------------------------------------------------------------------------\n");
        cout<<"User Simulator Thread Started: " << pthread_self()<<endl;
        fprintf(fp, "User Simulator Thread Started: %ld\n", pthread_self());
        // choose 100 random nodes from the graph
        // TODO: change this to 100
        for(int i=0;i<3;i++){
            int node_id = rand() % NNODES + 1;
            cout<<"\nChosen Node: " << node_id << " Neighbors: " << nodes[node_id].neighbors.size() << endl;
            fprintf(fp, "\nChosen Node: %d Neighbors: %d\n", node_id, (int)nodes[node_id].neighbors.size());
            int n = floor(log2(nodes[node_id].neighbors.size()));
            cout<<"Number of actions to be generated: " << n << endl;
            fprintf(fp, "Number of actions to be generated: %d\n", n);
            for(int j=0;j<n;j++){
                int action_no = rand() % 3;
                string action_type;
                if (action_no == 0)
                    action_type = "Post";
                else if (action_no == 1)
                    action_type = "Comment";
                else
                    action_type = "Like";
                Action action(node_id, j, action_type, time(NULL));
                cout<<"Action "<<j<<" generated:\n";
                action.Print();
                fprintf(fp, "Action %d generated:\n", j);
                fprintf(fp, "User_id: %d Action_id: %d Action: %s Timestamp: %s", node_id, j, action_type.c_str(), ctime(&action.timestamp));
                // push it to the wall queue of the user node
                nodes[node_id].wallQueue.push_back(make_pair(node_id, action));
                // push it to a queue monitored by pushUpdate threads
                //TODO: push it to a queue monitored by pushUpdate threads
            }
        } 
        cout<<"\nUser Simulator Thread Finished: " << pthread_self()<<endl;
        fprintf(fp, "\nUser Simulator Thread Finished: %ld\n", pthread_self());
        cout<<"-------------------------------------------------------------------------"<<endl;
        fprintf(fp, "-------------------------------------------------------------------------\n");
        fclose(fp);
        // sleep for 2 minutes;
        sleep(120);
    }    
}

void *readPostFn(void *arg){

}

void *pushUpdateFn(void *arg){
}

int main(int argc, char *argv[]){

    // The main thread will be responsible for reading the graph
    // it will then create a userSimulator thread
    // a pool of 10 readPost threads and another pool of 25 pushUpdate threads and wait for the threads
    srand(time(NULL));
    ReadGraph();
    pthread_t userSimulator;
    pthread_t readPost[10];
    pthread_t pushUpdate[25];

    //create the userSimulator thread
    // we create a log file sns.log
    FILE* fp = fopen("sns.log", "w");
    fclose(fp);
    pthread_create(&userSimulator, NULL, userSimulatorFn, NULL);

    //create the readPost threads
    for(int i=0;i<10;i++){
        pthread_create(&readPost[i], NULL, readPostFn,NULL);
    }

    //create the pushUpdate threads
    for(int i=0;i<25;i++){
        pthread_create(&pushUpdate[i], NULL, pushUpdateFn, NULL);
    }

    //wait for the userSimulator thread to finish
    pthread_join(userSimulator, NULL);
    
    // wait for the readPost threads to finish
    for(int i=0;i<10;i++){
        pthread_join(readPost[i], NULL);
    }

    // wait for the pushUpdate threads to finish
    for(int i=0;i<25;i++){
        pthread_join(pushUpdate[i], NULL);
    }

    return 0;
}