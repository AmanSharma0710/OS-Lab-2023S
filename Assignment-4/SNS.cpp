#include<iostream>
#include<vector>
#include<fstream>
#include<string>
#include<cmath>
#include<pthread.h>
#include<queue>
#include<stack>
#include<set>
#include<time.h>
#include<unistd.h>

#define NNODES 37700

using namespace std;

class Action{
    public:
        int user_id;
        int action_id;
        string action_type;
        time_t timestamp;
        Action(int user_id, int action_id, string action_type, time_t timestamp){
            this->user_id = user_id;
            this->action_id = action_id;
            this->action_type = action_type;
            this->timestamp = timestamp;
        }
        void Print(){
            // convert timestamp to readable format
            string time = ctime(&timestamp);
            cout<<"User_id: "<<user_id<<" Action_id: "<<action_id<<" Action: "<<action_type<<" Timestamp: "<<time;    
        }
};

class Node{
    public:
        int id;
        vector<int> neighbors;
        int priority;
        //     Each node U should maintain two queues:
        // ● Wall Queue: Will store the actions generated by the node U herself (see
        // below userSimulator thread function).
        // ● Feed Queue: Will store the actions generated by all neighbors of U (see
        // below readPost and pushUpdate functionalities).
        vector<pair<int, Action>> wallQueue;
        // TODO: change this to a priority queue which will be sorted by priority and timestamp
        vector<pair<int, Action>> feedQueue;
        int numLikes;
        int numComments;
        int numPosts;
        Node(){
            this->id = -1;
            this->neighbors = vector<int>();
            this->priority = -1;
            numLikes = 0;
            numComments = 0;
            numPosts = 0;
        }
        Node(int id){
            this->id = id;
            this->neighbors = vector<int>();
            this->priority = -1;
            numLikes = 0;
            numComments = 0;
            numPosts = 0;
        }
        void addNeighbor(int id){
            neighbors.push_back(id);
        }
        void Print(){
            cout << "Node: " << id << endl;
            cout << "Neighbors: ";
            for(int i=0; i<neighbors.size(); i++){
                cout << neighbors[i] << " ";
            }
            cout << endl;
        }
};


// global variables
vector<Node> nodes(NNODES);
// create a shared queue for userSimulator thread to push actions
// and pushUpdate threads to pop actions
queue<pair<int, Action>> actionQueue;
pthread_mutex_t PUmutex = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t PUcond = PTHREAD_COND_INITIALIZER;
pthread_mutex_t RPmutex = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t RPcond = PTHREAD_COND_INITIALIZER;


void ReadGraph(){
    int edges = 0;
    for(int i=0; i<NNODES; i++){
        nodes[i] = Node(i+1);
    }
    // read the nodes from the musae_git_edges.csv file
    // the first row contains the headers, ignore that
    // after that each row will have 2 columns denoting an edge between the nodes
    ifstream file("musae_git_edges.csv");
    string line;
    // ignoring the headers;
    getline(file, line);
    while(getline(file, line)){
        int node1, node2;
        int pos = line.find(",");
        node1 = stoi(line.substr(0, pos));
        node2 = stoi(line.substr(pos+1, line.length()));
        nodes[node1].addNeighbor(node2);
        nodes[node2].addNeighbor(node1);
        edges++;

    }
    // cout<<"Number of edges: " << edges << endl;
    // cout<<"Number of nodes: " << NNODES << endl;
    file.close();
}

void PushToFeedQueue(Action act, int node_id, pthread_t thread_id){
    // this function will push the action to the feed queue of all the neighbors of the node
    // with id node_id
    fopen("sns.log", "a");
    fprintf("PushToFeedQueue Thread: %ld\n", thread_id);
    for(int i=0; i<nodes[node_id].neighbors.size(); i++){
        int neighbor_id = nodes[node_id].neighbors[i];
        nodes[neighbor_id].feedQueue.push_back(make_pair(nodes[neighbor_id].priority, act));
        // write this into the log file
        fprintf(fp, "Pushed to Feed Queue of Node: %d\n", neighbor_id);
    }
    fclose(fp);
}

void *userSimulatorFn(void *arg){
    // this function will be executed by the userSimulator thread
    // it will generate random actions for 100 random users 
    // and push them to the wall queue of the user node
    // and push them to a queue monitored by pushUpdate threads
    while(true){
        // We will also log these statements in sns.log file
        FILE* fp = fopen("sns.log", "a");
        cout<<"-------------------------------------------------------------------------"<<endl;
        // write this into the log file
        fprintf(fp, "-------------------------------------------------------------------------\n");
        cout<<"User Simulator Thread Started: " << pthread_self()<<endl;
        fprintf(fp, "User Simulator Thread Started: %ld\n", pthread_self());
        // choose 100 random nodes from the graph
        // TODO: change this to 100
        for(int i=0;i<3;i++){
            int node_id = rand() % NNODES + 1;
            fprintf(fp, "\nChosen Node: %d Neighbors: %d\n", node_id, (int)nodes[node_id].neighbors.size());
            int n = floor(log2(nodes[node_id].neighbors.size()));
            n = 10(n+1);
            fprintf(fp, "Number of actions to be generated: %d\n", n);
            for(int j=0;j<n;j++){
                int action_no = rand() % 3;
                int action_id;
                string action_type;
                if (action_no == 0)
                    action_type = "Post";
                    numPosts++;
                    action_id = nodes[node_id].numPosts;
                else if (action_no == 1)
                    action_type = "Comment";
                    numComments++;
                    action_id = nodes[node_id].numComments;
                else
                    action_type = "Like";
                    numLikes++;
                    action_id = nodes[node_id].numLikes;
                Action action(node_id, action_id, action_type, time(NULL));
                fprintf(fp, "Action %d generated:\n", j);
                fprintf(fp, "User_id: %d Action_id: %d Action: %s Timestamp: %s", node_id, action_id, action_type.c_str(), ctime(&action.timestamp));
                // push it to the wall queue of the user node
                nodes[node_id].wallQueue.push_back(make_pair(node_id, action));
                // push it to a queue monitored by pushUpdate threads
                //TODO: push it to a queue monitored by pushUpdate threads
            }
        } 
        cout<<"\nUser Simulator Thread Finished: " << pthread_self()<<endl;
        fprintf(fp, "\nUser Simulator Thread Finished: %ld\n", pthread_self());
        cout<<"-------------------------------------------------------------------------"<<endl;
        fprintf(fp, "-------------------------------------------------------------------------\n");
        fclose(fp);
        // sleep for 2 minutes;
        sleep(120);
    }    
}

void *readPostFn(void *arg){
    // this will simulate the neighbours reading the 
    // actions generated by UserSimulator thread and pushed by
    // pushUpdate thread
    // this thread will monitor the neighbours whose feed queue might have 
    // changed and print messages of the form:
    // "I have read action number __ of type __ posted by user __ at time __"
    // it should continue till there is no message 
    // should come back whenever there are more messages to be read
    
    
}

void *pushUpdateFn(void *arg){
    // To monitor the actionQueue we will use a condition variable
    // we will also use a mutex to lock the condition variable
    // so that only one thread can pop an action at a time

    // TODO: do we need this thread to run forever?
    while()
    {
        pthread_mutex_lock(&PUmutex);
        // we will use a while loop to check if the actionQueue has pending actions
        while(actionQueue.empty()){
            pthread_cond_wait(&PUcond, &PUmutex);
        }
        // we will pop the action from the actionQueue
        Action act = actionQueue.front();
        actionQueue.pop_front();
        pthread_mutex_unlock(&PUmutex);
        // we will signal the condition variable to wake up the pushUpdate threads
        pthread_cond_signal(&PUcond);
        // we will push the action to the feed queue of all the neighbors of the node
        // and write this into the log file
        PushToFeedQueue(act.first, act.second, pthread_self());
    }
}

int main(int argc, char *argv[]){

    // The main thread will be responsible for reading the graph
    // it will then create a userSimulator thread
    // a pool of 10 readPost threads and another pool of 25 pushUpdate threads and wait for the threads
    srand(time(NULL));
    ReadGraph();
    pthread_t userSimulator;
    pthread_t readPost[10];
    pthread_t pushUpdate[25];

    //create the userSimulator thread
    // we create an empty log file sns.log
    FILE* fp = fopen("sns.log", "w");
    fclose(fp);
    pthread_create(&userSimulator, NULL, userSimulatorFn, NULL);

    //create the readPost threads
    for(int i=0;i<10;i++){
        pthread_create(&readPost[i], NULL, readPostFn,NULL);
    }

    //create the pushUpdate threads
    for(int i=0;i<25;i++){
        pthread_create(&pushUpdate[i], NULL, pushUpdateFn, NULL);
    }

    //wait for the userSimulator thread to finish
    pthread_join(userSimulator, NULL);
    
    // wait for the readPost threads to finish
    for(int i=0;i<10;i++){
        pthread_join(readPost[i], NULL);
    }

    // wait for the pushUpdate threads to finish
    for(int i=0;i<25;i++){
        pthread_join(pushUpdate[i], NULL);
    }

    return 0;
}